// These are the default config values. The values are changed to the user's preferences by readConfig()
var config = {
  columns: undefined, // Array of strings or numbers as the header name or column index of columns to be displayed. The leftmost column is index 0. If undefined, all columns will be displayed.
  floatPrecision: undefined, // Number for precision of floating point numbers. If undefined, floating numbers are not changed.
  formatNumbers: true, // Boolean value if numbers will be formatted with commas or not.
  headersInFile: true, // Boolean value if the table headers are included in the first line of the csv file or not.
  headers: undefined, // Array of strings containing header names. These names will be used as the headers of the table if headersInFile is false.
  notFormatted: undefined  // Array of strings or numbers as header names or column indexes. Content in these columns will not be formatted
};

// The driver function that starts the script
function CsvToTable(divID, csvFile, configObject) {
  document.getElementById(divID).innerHTML = "<table id='headersArea'><thead><tr id='headers'></tr></thead></table><div id='scrollArea' class='clusterize-scroll'><table><tbody id='contentArea' class='clusterize-content'><tr class='clusterize-no-data'><td>Loading dataâ€¦</td></tr></tbody></table></div>";

  readConfig(configObject);
  Papa.parse(csvFile, {
      download: true,
      header: config.headersInFile,
      dynamicTyping: true,
      complete: function(results) {
        loadDataFromPapa(results);
      },
      error: function(error) {
        throw new Error;
      }
    }
  );
}

// parses the configuration object and updates config
function readConfig(object) {
  if(object.columns != undefined) {
    config.columns = object.columns;
  }

  if(typeof(object.floatPrecision) === "number") {
    config.floatPrecision = object.floatPrecision;
  }

  if(object.formatNumbers != undefined) {
    config.formatNumbers = object.formatNumbers;
  }

  if(object.headersInFile != undefined) {
    config.headersInFile = object.headersInFile;
  }

  if(Array.isArray(object.headers)) {
    config.headers = object.headers;
  }

  if(object.notFormatted != null) {
    config.notFormatted = object.notFormatted;
  }
}

// unparses the data from Papaparse into HTML and displays it on the page
function loadDataFromPapa(data) {
  var header = undefined;

  if(config.headersInFile) {
    if(data.meta.fields != undefined) {
      header = data.meta.fields;
    }
  } else if(config.headers != undefined) {
    header = config.headers;
  }
  
  var headersHTML = "";
  if(header != undefined) {
    var headerHTML = "";
    for(var i = 0; i < header.length; i++) {
      if(config.headers != undefined || config.columns == undefined || (config.columns != undefined && config.columns.indexOf(header[i]) != -1)) {
        headersHTML += "<th>" + header[i] + "</th>";
      }
    }

    document.getElementById("headers").innerHTML = headersHTML;
  }

  var htmlArray = dataToHTMLTable(header, data.data);

  loadClusterize(htmlArray);
}

// Takes in the data that was parsed by Papa and returns an array of HTML strings that can be passed to Clusterize
function dataToHTMLTable(header, data) {
  var htmlArray = [];

  for(var i = 0; i < data.length; i++) {
    var htmlString = "<tr>";
    var rows;
    if(header != undefined && !Array.isArray(data[i])) {
      rows = header.length;
    } else {
      rows = data[i].length;
    }

    for(var n = 0; n < rows; n++) {
      var index;
      if(headers != undefined && !Array.isArray(data[i])) {
        index = header[n];
      } else {
        index = n;
      }

      // skips column if it is not listed in columns in config
      if(config.columns != undefined && config.columns.indexOf(index) == -1) {
        continue;
      }

      if(typeof(data[i][index]) == "number" && config.formatNumbers 
        && (config.notFormatted == undefined || config.notFormatted.indexOf(index) == -1)) {

        htmlString += formatNumber(data[i][index]) + "</td>";
      } else {
        htmlString += "<td>" + data[i][index] + "</td>";
      }
    }
    htmlArray.push(htmlString + "</tr>");
  }

  return htmlArray;
}

// takes a number and adds commas if above 1000 and sets precision of float according to floatPrecision in config
// returns result as a string
function formatNumber(number) {
  if(config.floatPrecision != undefined && number % 1 != 0) {
    number = number.toFixed(config.floatPrecision);
  }
  
  return "<td style='text-align: right;'>" + number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// Constructs clusterize with the HTML string "data"
// data is an HTML string
function loadClusterize(data) {
  var clusterize = new Clusterize({
    rows: data,
    scrollId: 'scrollArea',
    contentId: 'contentArea',
    callbacks: {
      clusterChanged: function() {
        // These functions are called whenever clusterize changes the table
        // This usually happens with large data when the user scrolls far enough
        fitHeaderColumns();
        setHeaderWidth();
        fitTbodyToHeaders();
      }
    }
  });
}

// Makes header columns equal width to content columns
var fitHeaderColumns = (function() {
  var prevWidth = [];
  return function() {
    var $firstRow = $('#contentArea').find('tr:not(.clusterize-extra-row):first');
    var columnsWidth = [];
    $firstRow.children().each(function() {
      columnsWidth.push($(this).width());
    });
    if (columnsWidth.toString() == prevWidth.toString()) return;
    $('#headersArea').find('tr').children().each(function(i) {
      $(this).width(columnsWidth[i]);
    });
    prevWidth = columnsWidth;
  }
})();

// Keep header equal width to tbody
var setHeaderWidth = function() {
  $('#headersArea').width($('#contentArea').width());
}

// Set left offset to header to keep equal horizontal scroll position
var setHeaderLeftMargin = function(scrollLeft) {
  $('#headersArea').css('margin-left', -scrollLeft);
}

// Set width of the topmost row to match the headers
function fitTbodyToHeaders() {
  var header = document.getElementById("headers");
  var content = document.getElementById("contentArea");

  var headerElems = header.childNodes;
  var contentRow = content.childNodes[0].childNodes;

  // Clusterize sometimes puts an empty element at index 0 and 1
  if(contentRow.length == 0 && content.childNodes.length >= 3) {
    contentRow = content.childNodes[2].childNodes;
  }

  for(var i = 0; i < headerElems.length; i++) {
    if(headerElems[i].offsetWidth > contentRow[i].offsetWidth) {
      // setting min and max the same forces the width to never change
      contentRow[i].style.minWidth = headerElems[i].offsetWidth.toString() + "px";
      contentRow[i].style.maxWidth = headerElems[i].offsetWidth.toString() + "px";
    }

    setHeaderWidth();
    fitHeaderColumns();
  }
}